# Book.Scanning.Initial.Solutions

This repository contains constructive solutions for the Book Scanning Problem. These solutions will be used as initial solutions in metaheuristic algorithm solutions to the Book Scanning Problem.

These solutions are generated by using varying LLMs (ChatGPT 4, ChatGPT 5, Cloude etc) and prompts. The following framework was used:
1. Give the problem definition to the LLM
2. Prompt to generate a solution
3. Run the solution for a instance
4. Tell the score of the solution to the LLM and prompt to get a better solution
5. Do the steps 1-4 until the context of the LLM is exhaust

## Constructive Solutions

### Elite-Threshold Adaptive Greedy _(generate_initial_solution_elite_threshold)_

Deterministic, fully adaptive greedy with a value-based RCL (threshold = s_min + α(s_max−s_min)). At each step it recomputes each library’s true marginal gain (top unscanned books within remaining capacity), builds the RCL, then breaks ties by smaller signup_days → larger books_per_day → larger score. No randomness, no local search.

### Sorted-Order Deterministic Greedy _(generate_initial_solution_ordered_list)_

Purely deterministic “sorted sweep.” Uses the same presort as above and takes libraries in that exact order if feasible, grabbing their best unscanned books. Essentially GRASP with p ≈ 0 (no randomness, no adaptivity in ordering).

### Static Efficiency Greedy _(generate_initial_solution_static_greedy)_

One-shot efficiency heap built from day-0 assumptions: efficiency = (potential score if started immediately) / signup_days. Pops best, tries to schedule it at the evolving current time, and never recomputes other libraries’ keys as days/book availability change (hence “static”). Fast but myopic.

### Weighted-Efficiency Greedy _(generate_initial_solution_weighted_efficiency)_

Adaptive greedy with a growing penalty: at each step, recomputes each lib’s real marginal score (given current time + seen books) and chooses the max of score / [(signup_days^α)·(1 + β·used_libs)]. This progressively favors shorter signups as the plan grows.

### Adaptive Efficiency Heap _(generate_initial_solution_adaptive_heap)_

Starts with a heap keyed by “efficiency” estimated from day-0 capacity. Greedily pops, schedules, and updates the seen set; occasionally rebuilds the heap to refresh efficiencies with the current time and unscanned books (triggered infrequently by a size-based check). More adaptive than the static heap, but still less consistently recalculated than the elite-threshold approach.
